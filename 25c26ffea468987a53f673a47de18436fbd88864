{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c49996b1_e98e81b7",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 21,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-01-18T16:27:36Z",
      "side": 1,
      "message": "On Arm CCA enabled HW, do we expect a synchronous external abort because of the TZC, or a GPF?\nIs this worth checking ESR_EL2.DFSC?",
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47574b66_38f0a114",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 21,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-01-21T10:36:28Z",
      "side": 1,
      "message": "Based on the test address definition (points to Trusted SRAM) the data abort type is synchronous external abort because the target implements a slave side filter gating a non-secure access request.\nTo be clear the test does not exercise the TZC400 or the GPC. This is perfectly ok but just wanted to emphasize it, perhaps fez comments or a commit message update is worth.",
      "parentUuid": "c49996b1_e98e81b7",
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "535f8e02_450dff94",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 21,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2022-01-22T05:42:31Z",
      "side": 1,
      "message": "On CCA, this should result in GPF sync exception no, since the GPC fails?",
      "parentUuid": "47574b66_38f0a114",
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "866247b6_b5c85faf",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 21,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-02-23T06:54:23Z",
      "side": 1,
      "message": "Yes on 2 worlds system, a sync ext abort triggers if accessing Trusted SRAM (response from fabric) or DRAM because protected by TZC.\nOn 4 worlds system, it is always a GPF exception because the \u0027third stage\u0027 MMU gates the access even before reaching the target.",
      "parentUuid": "535f8e02_450dff94",
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a224d1c_49cf3a1f",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-01-18T16:27:36Z",
      "side": 1,
      "message": "Does it make sense to actually check a flag or counter to prove that data_abort_handler has been called?",
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddbbf696_772f0eae",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-01-18T16:54:39Z",
      "side": 1,
      "message": "nitpick: for robustness, since this address is mapped as RW, can we check for write access, which should also lead to sync abort",
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18549808_1c218951",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2022-01-18T21:11:36Z",
      "side": 1,
      "message": "if this read from memory gets executed speculatively, it is possible that we might end up getting an SError. This is marked as normal memory so a core is free to order it before the call to register_custom_sync_exception handler. on aggressively out of order cores, you might not see the abort handler being called. Likely need a barrier between registration and dereference of test address.\nSame for after the access. access can be ordered after unregister_custom_sync and then you wont have a handler if core reorders the access.",
      "range": {
        "startLine": 36,
        "startChar": 24,
        "endLine": 36,
        "endChar": 36
      },
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a34b0876_f5074a33",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-01-21T10:36:28Z",
      "side": 1,
      "message": "Agree on the need for barriers.\n\n\u003eif this read from memory gets executed speculatively, it is possible that we might end up getting an SError.\nJust curious, why an SError rather than a sync external abort from the TZC (but too early as you say because the handler is not yet registered)? If an SError is triggered it\u0027s possible it\u0027s not caught because of PSTATE.A is masked. If unmasked it would result in calling the SError exception handler (aka unhandled exception)?",
      "parentUuid": "18549808_1c218951",
      "range": {
        "startLine": 36,
        "startChar": 24,
        "endLine": 36,
        "endChar": 36
      },
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e7ca42a_17e6ed0a",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2022-01-22T05:42:31Z",
      "side": 1,
      "message": "Serror could happen due to the load executing speculatively (since address is marked as normal memory) or the core deciding to prefetch the memory into cache in anticipation of the load and the request for the cache line is sent out to memory, but the access violates TZC policy and an error response is sent back. There is no committed load in the core yet to peg the error response to, so the core may decide to map it as an SError.\n\nAnd i think i want to take back my comment about requiring barriers. In general each core should perceive its memory accesses as occurring in program order (reorder buffer should commit everything in program order) and the compiler should not move things across the volatile access...so i think we may be fine without barriers..",
      "parentUuid": "a34b0876_f5074a33",
      "range": {
        "startLine": 36,
        "startChar": 24,
        "endLine": 36,
        "endChar": 36
      },
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a638702_e256a1df",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-02-23T06:54:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1a224d1c_49cf3a1f",
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89446a8e_1e59d4cc",
        "filename": "tftf/tests/misc_tests/test_invalid_access.c",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-02-23T06:54:23Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "4e7ca42a_17e6ed0a",
      "range": {
        "startLine": 36,
        "startChar": 24,
        "endLine": 36,
        "endChar": 36
      },
      "revId": "25c26ffea468987a53f673a47de18436fbd88864",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}