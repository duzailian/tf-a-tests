{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5ca86aae_d8d072d6",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_direct_messaging.c",
        "patchSetId": 4
      },
      "lineNbr": 205,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-02-21T15:43:21Z",
      "side": 1,
      "message": "i know we discussed this in other patches too but i\u0027m not entirely convinced of the idea that primary/first SP is treated differently than the secondary sp\u0027s. In a system where normal world  and secure world components come from different vendors, such coupling becomes problematic. Normal world should not really require to know which EC belongs to a primary/first SP or secondary SP. Would suggest to take a closer look at another solution.\n\nA brute force way would be to run EC\u0027s of all SP\u0027s on a PSCI_CPU_ON call. or bake this into the direct request call such that an EC that is not woken up is woken up to the message loop before processing the actual message.",
      "range": {
        "startLine": 201,
        "startChar": 1,
        "endLine": 205,
        "endChar": 4
      },
      "revId": "f137e719598f35d758e04ef090083a17b5fcb0b1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8d5eb80_4dbd9dbd",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_direct_messaging.c",
        "patchSetId": 4
      },
      "lineNbr": 205,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-03-02T18:59:08Z",
      "side": 1,
      "message": "\u003e i\u0027m not entirely convinced of the idea that primary/first SP is treated differently than the secondary sp\u0027s.\nI appreciate this is not a complete/final solution but needed at least to bring up a single partition in form of a TEE. In later changes, the intent is for SPs to register PM events.\n\n\u003e bake this into the direct request call such that an EC that is not woken up is woken up to the message loop before processing the actual message.\nThis isn\u0027t really possible because the first direct message request used for the sake of allocating cycles to \"secondary ECs\" would never get a response. The message loop is entered by a first call to FFA_MSG_WAIT which is not a valid response to a direct message request.\n\n\u003e A brute force way would be to run EC\u0027s of all SP\u0027s on a PSCI_CPU_ON call.\nBy the PSCI implementation, this happens on a per core basis and a PM event received on one core cannot influence what happens to other cores.\nThe first EC for each SP gets executed at boot time, this is an opportunity for each SP to initialize itself at least on one context.\nWe agreed in early discussions this is not reasonable to relay any PM event to all SPs as a general rule for latency/performance reasons. It\u0027s likely a platform only allows a limited subset of SPs to receive PM events. This is done on a SP registration basis with a policy for the integrator to limit the number of SPs able to receive PM events.",
      "parentUuid": "5ca86aae_d8d072d6",
      "range": {
        "startLine": 201,
        "startChar": 1,
        "endLine": 205,
        "endChar": 4
      },
      "revId": "f137e719598f35d758e04ef090083a17b5fcb0b1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc46eba2_cfec1b2a",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_direct_messaging.c",
        "patchSetId": 4
      },
      "lineNbr": 205,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-03-02T19:01:34Z",
      "side": 1,
      "message": "Ignore this sentence \"By the PSCI implementation, this happens on a per core basis and a PM event received on one core cannot influence what happens to other cores.\" I misinterpreted what you said.",
      "parentUuid": "b8d5eb80_4dbd9dbd",
      "range": {
        "startLine": 201,
        "startChar": 1,
        "endLine": 205,
        "endChar": 4
      },
      "revId": "f137e719598f35d758e04ef090083a17b5fcb0b1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3009307_85340edf",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_direct_messaging.c",
        "patchSetId": 4
      },
      "lineNbr": 205,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-03-02T21:45:55Z",
      "side": 1,
      "message": "Thanks Olivier. Why would \" bake this into the direct request call such that an EC that is not woken up is woken up to the message loop before processing the actual message.\" not work for those EC\"s that do not register power events? I find it odd to expect normal world software to know which SP\u0027s registered to power events and which did not. That works in tightly integrated systems but not in systems where SP\u0027s may come from different parties and things work based on discovery. At the least, the FF-A spec should provide a method for normal world to discover whether an SP registers for FF-A run or if normal world needs to call ffa_run once, before it sends direct messages. What do you think?\n\nAlso \"I appreciate this is not a complete/final solution but needed at least to bring up a single partition\" - Assume always that my comments are meant for discussion/learning/understanding and not to block a patch :) Totally understand that there are more immediate goals than to indulge my requirements!",
      "parentUuid": "cc46eba2_cfec1b2a",
      "range": {
        "startLine": 201,
        "startChar": 1,
        "endLine": 205,
        "endChar": 4
      },
      "revId": "f137e719598f35d758e04ef090083a17b5fcb0b1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fab228b_9f402e8f",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_direct_messaging.c",
        "patchSetId": 4
      },
      "lineNbr": 205,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-03-03T09:44:59Z",
      "side": 1,
      "message": "Hi Raghu,\n\u003e\" bake this into the direct request call such that an EC that is not woken up is woken up to the message loop before processing the actual message.\" not work for those EC\"s that do not register power events?\n\nTo provide a bit more details, there is this condition to fulfill in the SPMD:\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/services/std_svc/spmd/spmd_main.c?h\u003dv2.4#n618\nEach physical core woken up pinned to a corresponding vCPU in the first SP must return with FFA_MSG_WAIT as the only option to indicate a successful initialization. Then the SPMD toggles the physical CPU state to ON here:\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/services/std_svc/spmd/spmd_pm.c?h\u003dv2.4#n110\nWhen all cores are booted, all ECs in the first SP and the first EC in other SPs (1) reached the message loop. It means for other ECs (2), a round of ffa_run is needed to reach the message loop and emit ffa_msg_wait. For those ECs sending a direct message request straight would fail because the direct message request would be conveyed at the SP entry point rather than resuming the SP within the message loop (after ffa_msg_wait).\n\n\u003e At the least, the FF-A spec should provide a method for normal world to discover whether an SP registers for FF-A run or if normal world needs to call ffa_run once, before it sends direct messages. What do you think?\n\nI guess we can convey this to Achin for specification related aspects.\n\n\u003e Assume always that my comments are meant for discussion/learning/understanding and not to block a patch :) Totally understand that there are more immediate goals than to indulge my requirements!\n\nNo worries. I see it as an iterative approach and we already have dependencies to those change sets (Total Compute goals, FF-A compliance test suite, ...) which took very long to mature. I hope this initial thinking is fair enough to fulfill at least FF-A v1.0. Obviously we will refine things as we enter into more complex PM scenarios and as the spec evolves.",
      "parentUuid": "b3009307_85340edf",
      "range": {
        "startLine": 201,
        "startChar": 1,
        "endLine": 205,
        "endChar": 4
      },
      "revId": "f137e719598f35d758e04ef090083a17b5fcb0b1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d421d96_fdec9f33",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_direct_messaging.c",
        "patchSetId": 4
      },
      "lineNbr": 205,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-03-03T16:43:53Z",
      "side": 1,
      "message": "Olivier, i understand this \"When all cores are booted, all ECs in the first SP and the first EC in other SPs (1) reached the message loop. It means for other ECs (2), a round of ffa_run is needed to reach the message loop and emit ffa_msg_wait. For those ECs sending a direct message request straight would fail because the direct message request would be conveyed at the SP entry point rather than resuming the SP within the message loop (after ffa_msg_wait).\"\n\nLet me try again. Imagine if we call api_ffa_run inside api_ffa_send_direct_req, if we find that the vcpu is in off state. Why can we not do that? If we realize the vcpu is off, we save off the direct request paramaters, within the direct_req call, call ffa_run on the vcpu which would then enter the SP at the entry point, and the SP would call msg wait in the loop. When we get the message wait, just like the line you pointed out, we can see if there was a pending direct_req on the message wait, and then make the direct_req_call.\nWould that not work?\n\nThe advantage of doing so is not having to modify the spec and normal world need not be aware of what is the first sp or second sp and make the special call for ffa_run on non-first SP.",
      "parentUuid": "4fab228b_9f402e8f",
      "range": {
        "startLine": 201,
        "startChar": 1,
        "endLine": 205,
        "endChar": 4
      },
      "revId": "f137e719598f35d758e04ef090083a17b5fcb0b1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}