{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3dce2f77_48e31472",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 22,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-12-08T14:33:28Z",
      "side": 1,
      "message": "Insert an empty line between 21 and 22",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fedc31a8_86451299",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 22,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2022-12-08T23:02:09Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3dce2f77_48e31472",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ff17af2_c7026915",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-12-08T14:33:28Z",
      "side": 1,
      "message": "can you change all INFO to VERBOSE",
      "range": {
        "startLine": 26,
        "startChar": 1,
        "endLine": 26,
        "endChar": 5
      },
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f15a76bb_a02fc222",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2022-12-08T23:02:09Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3ff17af2_c7026915",
      "range": {
        "startLine": 26,
        "startChar": 1,
        "endLine": 26,
        "endChar": 5
      },
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0585ca4_e74bca58",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-12-08T15:38:57Z",
      "side": 1,
      "message": "Shouldn\u0027t there be a boundary for the number of loop iterations? Something very small like 3 or 5? And then fail the test?\nAnother thing to test could be to read the PMU cycle counter, and to compare the time each call takes against some ballpark number for a native call, to verify that it actually involves a trap.",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "320d2e42_ea88efdd",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2022-12-08T23:02:09Z",
      "side": 1,
      "message": "Hi Andre, thanks for looking into this. \nWith respect to the loop iterations, I don\u0027t like the idea of an infinite loop either. I wasn\u0027t sure of how many iterations would be enough to get a new value from the entropy, so I left it infinite.\nI also like the second idea. However, the PMU might not be able to give EL2 the information about what happens in EL3, so we would probably end up having counting the same number, whether with FEAT_RNG_TRAP enabled or not. Madhu suggested me to print something out in the trap handler and track that with an expect script. Maybe that is a better approach. I\u0027m open to suggestions thoguh.",
      "parentUuid": "e0585ca4_e74bca58",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c112527a_1e201bce",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-12-08T23:52:39Z",
      "side": 1,
      "message": "loop iterations: *every* call to either RNDR or RNDRRS should always give you a random number, from a pseudo RNG. The latter version only re-seeds this DRNG before getting the next value. Now \"random\" theoretically also includes the ever so slightest probability of returning the same number twice, but for a proper DRNG with 64-bit return values this is *extremely* unlikely. That\u0027s why I suggested 3 as the loop count as the limit.\n\nAnd I don\u0027t know for sure if cycles spent in secure are visible to the non-secure counter, but this would be worth an experiment: Read the cycles with ENABLE_RNG_TRAP\u003d0, to measure how many cycles the model takes. Then do the same with the trap enabled, and check how the numbers differ.\n\nIf you want to be really eager, you could run some statistical tests on a number of returned values, but this might be overkill for this test.\nOne other thing worth checking is if the emulation corrupts GPRs, but this sounds also optional.",
      "parentUuid": "320d2e42_ea88efdd",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5a1e7a5_30214a4d",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2022-12-13T09:36:27Z",
      "side": 1,
      "message": "\u003e One other thing worth checking is if the emulation corrupts GPRs, but this sounds also optional.\n\nIdeally it should not corrupt any registers, if save/restore is done properly. FYI, There is an activity planned to introduce generic tests where save/restore functionality is tested.",
      "parentUuid": "c112527a_1e201bce",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60ce0048_bacd8143",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2022-12-13T09:40:26Z",
      "side": 1,
      "message": "@Juan, I guess we should divide this test in two parts\n1. Test if syreg trap working or not ? read_rndr() once and ensure that execution went to EL3\n2. Test whether random number is unique or not ? which would not have details of 1st test.",
      "parentUuid": "b5a1e7a5_30214a4d",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac8e0e10_4b1d0112",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2022-12-13T09:50:23Z",
      "side": 1,
      "message": "\u003e 1. Test if syreg trap working or not ? read_rndr() once and ensure that execution went to EL3\nOne of the hacky way to test this is, create a small patch file in CI scripts which on entering sysreg handler increments a count in NS memory and TFTF then reads this value before/after to ensure counter incremented. This is one of the way we are planning for future tests(context mgmt) for those registers which are not accessible to TFTF",
      "parentUuid": "60ce0048_bacd8143",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f6462ff_00aebfdd",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-12-13T10:28:06Z",
      "side": 1,
      "message": "\"Ideally it should not corrupt any registers\"\u003e Yes, but this is something that could easily go wrong in the implementation. After all I deliberately tinker with the context in EL3. So I think it should be part of the test. And you would be amazed how far you get when you accidentally corrupt one of the lower registers.\nTBH, finding a random value in a register after an RNDR call isn\u0027t really a demanding test.\nBut I agree that this is a general problem: checking for register corruption after going to EL3, since this applies to SMCCC calls as well.\nSo we should have a routine that saves all registers before doing the smc call, and saves them again afterwards, to allow comparing. We could also provide a mask that states which register can be corrupted. For this trap here we only allow exactly one register to change, for SMCCC calls the list could be longer, depending on the actual service called.\n\n\"ensure that execution went to EL3\"\u003e This is somewhat tricky to pull off, architecturally. I will try some heuristics, for instance whether the cycle counter keeps ticking. James Morse also mentioned that load/store exclusive would *always* fail over an exception, which might be a good enough hint.\nI don\u0027t think patching BL31 is a good idea, since you then test this changed code, not the actually deployed firmware.",
      "parentUuid": "ac8e0e10_4b1d0112",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e40bf74c_930421b9",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-12-13T17:16:02Z",
      "side": 1,
      "message": "So I tried the PMU cycle counter, but couldn\u0027t get it to tick at all (in EL2). Anyway it seems this might not work anyway, when/if BL31 blocks cycle counting in secure and/or EL3.\nBut the load/store exclusive trick worked. The ARMv8 ARM says in chapter B2.9.4 (Context switch support): \"An exception return clears the local monitor.\"\nAnd here is a code sketch for that:\n\n#define MAX_TRIES 100\nstatic bool does_rndr_trap(void)\n{\n       uint64_t exclusive, reg;\n       int i;\n\n       for (i \u003d 0; i \u003c MAX_TRIES; i++) {\n               __asm__ volatile (\"ldxr %0, %1\\n\" : \"\u003dr\"(reg) : \"Q\"(exclusive));\n               __asm__ volatile (\"mrs %0, S3_3_C2_C4_0\\n\" : \"\u003dr\" (reg));\n               __asm__ volatile (\"stxr %w0, %1, %2\\n\" : \"\u003d\u0026r\"(reg)\n                                 : \"r\"(0x42), \"Q\"(exclusive));\n               if (reg \u003d\u003d 0)\n                       break;\n       }\n\n       return i \u003d\u003d MAX_TRIES;\n}\n\nHope that helps!",
      "parentUuid": "8f6462ff_00aebfdd",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99cb1cab_679c3933",
        "filename": "tftf/tests/extensions/rng_trap/test_rndr_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2022-12-13T17:54:43Z",
      "side": 1,
      "message": "Yeah. I tried the PMU and it doesn\u0027t show any difference either in cycle or event counting for tests with and without FEAT_RNG_TRAP enabled. \n\nWith respect to corrupting the GPRs, I don\u0027t know. As Manish said, the context is assumed to be saved and restored properly. Even if there is a flaw and some register gets corrupted for some reason, at some point that will be fixed and the test will become useless. \n\nAs for the counter, maybe it is a good idea. Another option is printing something out from the handler and then using an expect script to check that.",
      "parentUuid": "e40bf74c_930421b9",
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23bc826b_6b6a69c2",
        "filename": "tftf/tests/extensions/rng_trap/test_rndrrs_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 27,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-12-08T14:33:28Z",
      "side": 1,
      "message": "nit: change INFO to VERBOSE",
      "range": {
        "startLine": 27,
        "startChar": 1,
        "endLine": 27,
        "endChar": 5
      },
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b191d8b6_ee18d204",
        "filename": "tftf/tests/extensions/rng_trap/test_rndrrs_trap.c",
        "patchSetId": 2
      },
      "lineNbr": 27,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2022-12-08T23:02:09Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "23bc826b_6b6a69c2",
      "range": {
        "startLine": 27,
        "startChar": 1,
        "endLine": 27,
        "endChar": 5
      },
      "revId": "4cae3ed198544ff06bfcd79db9f33114a02293d2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}