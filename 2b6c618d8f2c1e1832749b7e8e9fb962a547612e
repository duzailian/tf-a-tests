{
  "comments": [
    {
      "key": {
        "uuid": "2d8958ad_4321c0f0",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-06-18T22:04:37Z",
      "side": 1,
      "message": "why do you need a ret? This is a macro, so cannot be called from C files and if it is to be used in assembly, it can only be used at the end of a function. Seems like it is coded to be used only in the amu file... might want to leave out the ret here and keep the ret instruction in the amu assembly.",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82b1ef16_a59fc707",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2020-06-19T12:18:02Z",
      "side": 1,
      "message": "This is macro which defines a function, which is called by \"br x1\" instruction.\nSee definition in TF-A:\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/include/arch/aarch64/asm_macros.S#n200\nIts usage in TF-A:\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/lib/extensions/amu/aarch64/amu_helpers.S#n43\nIts usage in TFTF:\nhttps://review.trustedfirmware.org/c/TF-A/tf-a-tests/+/4622/2/lib/extensions/amu/aarch64/amu_helpers.S#40",
      "parentUuid": "2d8958ad_4321c0f0",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8d0c540_b0f4c2fd",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-06-19T15:13:04Z",
      "side": 1,
      "message": "\"this is MACRO which defines a FUCNTION\" - The statement itself is confusing. Would you consider func read reg:req instead? It is confusing to a reader(at least me) if it is a macro and ends with a ret. If it is a func, it\u0027ll be clear that this can be called using a branch instruction. The macro seems not useful anywhere else except in the amu_helper.S the way it is written and your links suggest that too. This can be a generic macro/func that can be used in other places too if the ret is removed.\n\nMoreover, i question the usefulness of the bti instruction in this case. This is a perfect gadget to read system registers for ROP/JOP attacks by the very fact that bti has been added followed by one instruction followed by a ret. I wonder if the same function from amu_helpers.S was written in C, what code the compiler would generate. If it ends up spraying a bunch of BTI\u0027s like we are doing here, then i guess it is okay.",
      "parentUuid": "82b1ef16_a59fc707",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71fcad01_247f92df",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2020-06-19T16:16:14Z",
      "side": 1,
      "message": "What\u0027s about these macros here:\n\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/lib/cpus/aarch64/wa_cve_2017_5715_bpiall.S#n18\n.macro\tapply_cve_2017_5715_wa _from_vector\n\t/*\n\t * Save register state to enable a call to AArch32 S-EL1 and return\n\t * Identify the original calling vector in w2 (\u003d\u003d_from_vector)\n\t * Use w3-w6 for additional register state preservation while in S-EL1\n\t */\n\n\t/* Save GP regs */\n\tstp\tx0, x1, [sp, #CTX_GPREGS_OFFSET + CTX_GPREG_X0]\n....\nmsr\tscr_el3, xzr\n\tmsr\tspsr_el3, x8\n\tmsr\tvbar_el3, x9\n\tmsr\tsctlr_el1, x10\n\tmsr\telr_el3, x11\n\n\teret\n\t.endm\n\nand here\n\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/lib/aarch64/cache_helpers.S#n22\nhttps://git.trustedfirmware.org/TF-A/tf-a-tests.git/tree/lib/aarch64/cache_helpers.S#n22\n\n/*\n * This macro can be used for implementing various data cache operations `op`\n */\n.macro do_dcache_maintenance_by_mva op\n\t/* Exit early if size is zero */\n\tcbz\tx1, exit_loop_\\op\n\tdcache_line_size x2, x3\n\tadd\tx1, x0, x1\n\tsub\tx3, x2, #1\n\tbic\tx0, x0, x3\nloop_\\op:\n\tdc\t\\op, x0\n\tadd\tx0, x0, x2\n\tcmp\tx0, x1\n\tb.lo    loop_\\op\n\tdsb\tsy\nexit_loop_\\op:\n\tret\n.endm\n\nAre you suggesting that (e)ret instructions should be removed or macros replaced with functions?\n\nShow me in that definition of macro:\n\nhttp://www.keil.com/support/man/docs/armasm/armasm_dom1359731154916.htm\n\"A macro definition is a block of code enclosed between MACRO and MEND directives. It defines a name that you can use as a convenient alternative to repeating the block of code.\nThe main uses for a macro are:\n    To make it easier to follow the logic of the source code by replacing a block of code with a single meaningful name.\n    To avoid repeating a block of code several times.\"\n\nwhere it is said that it is not allowed to have a (e)ret instruction.\n\nThis change matches the similar TF-A code (except that there is no write macro) and commit message clearly states that. This macro can be used not only in amy_helper.S but in any other driver which needs the same sort of calling method (blr x, br x).\n\nYou wrote:\n\"Would you consider func read reg:req instead?\"\n\nLook at\nhttps://git.trustedfirmware.org/TF-A/tf-a-tests.git/tree/include/common/asm_macros_common.S#n17\n\nAre you aware that \"func\" is a macro itself?\n.macro func _name\n\nand would you explain how \"func\" can get system register as a parameter to use in \"mrs\" instruction?",
      "parentUuid": "c8d0c540_b0f4c2fd",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1deaa502_71f4a4bb",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2020-06-19T16:18:43Z",
      "side": 1,
      "message": "I didn\u0027t write anytning about \"FUCNTION\"",
      "parentUuid": "71fcad01_247f92df",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1c08abb_530c7467",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-06-19T17:03:11Z",
      "side": 1,
      "message": "\u003e\u003eThis change matches the similar TF-A code\n\nThanks for the explanation. Firstly, \"what about\u0027s\" are not an answer to everything. Just because something has been done in the past does not mean we have to follow it in the future. I urge you to consider the possibility that we can always improve and not blindly follow what has been done in the past. Not everything is perfect in TF-A:)\n\nHave you considered that the examples you showed may have been doing it incorrectly? Have you noticed the macros are in their own files and not in the generic asm_macros.S file? Can you think of why that may be the case? And if you look at the rest of the macros in this file, do you see anything ending with ret? Does that not seem odd and worth questioning? Using your own logic, if you consider macro patterns(not func, which is a special macro which indicates usage of ret) in TF-A, would you not consider having RET\u0027s in the macro an outlier rather than the norm?\n\nSince you pointed out func is a macro(which i forgot and missed the parameter aspect of it), have you considered that maybe you need a better name than simply \"read\" or \"write\" that provides no context about it being called by br x1. Other than you, the code author, nobody knows these hidden details and assumptions, which can be missed while reviewing code. Have you considered that i may have missed that because of the way the code is written? Instead of \"what about\u0027s\" can you consider discussing how you can help make it clearer to a reader? Perhaps a nice long comment on top of the macro? Maybe the macro can live in amu_helpers.S?\n\n\u003e\u003eAre you suggesting that (e)ret instructions should be removed or macros replaced with \u003e\u003efunctions ? where it is said that it is not allowed to have a (e)ret instruction.\n\nJust because something is unsaid, does not mean it is not worth thinking about. See above. How many macros in TF-A end with an ERET or RET? It just seems odd for THIS macro to end with RET which is why i posted a comment. i can see it happening with function epilogues for example but that would give you an indication about it being a function epilogue, perhaps by its name.",
      "parentUuid": "71fcad01_247f92df",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "782829de_ddfec2de",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2020-06-19T17:45:49Z",
      "side": 1,
      "message": "Please feel free to raise a defect for using \"(e)ret\" instructions in TF-A and TFTF source trees and to provide a solution for fixing that issue.\nWould you give a working example of a single function which will accept system register name as a parameter for \"mrs\" and can be used for 20 places in TFTF and TF-A code where it is called?",
      "parentUuid": "c1c08abb_530c7467",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caaf6579_994a6c66",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-06-19T18:27:16Z",
      "side": 1,
      "message": "i already conceded that you cannot use a function, obviously, so the macro is fine. I recommend changing the name to something like read_sys_reg_ret/write_sys_reg_ret, adding a comment that says this is expected to be invoked only by a br instruction when BTI is enabled. The _ret post-fix should hopefully be clear enough that the macro includes a ret. amu_helpers.S otherwise looks like it is a sequence of reads and completely misses the hidden ret.",
      "parentUuid": "782829de_ddfec2de",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c9c0ed9_6c047692",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2020-06-22T11:36:27Z",
      "side": 1,
      "message": "The original complaint which resulted in -1 for the code review was about using function:\n\"why do you need a ret?\"...\"this is MACRO which defines a FUCNTION\" - The statement itself is confusing. Would you consider func read reg:req instead?\"...\n\nNow it is macro name itself... As I already pointed out this patch fully matches the code in TF-A, which was reviewed and merged on 24 May 2019. You can see the comment from ARM TF-A project tech. leader who has been working on this project for several years here:\nhttps://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/929/4/lib/extensions/amu/aarch64/amu_helpers.S#14\nNobody since then has ever complained that \"It is confusing to a reader(at least me) if it is a macro and ends with a ret\" suggesting using \" a better name than simply \"read\" or \"write...\"\nThe intention is to keep TFTF sources as close to TF-A as possible ans use the similar macros/functions\u0027 names which makes it easier to debug, maintain and fix the issues.\n\nNow about \"Moreover, i question the usefulness of the bti instruction in this case. \"\nThis \"bti j\" instruction is not just \"useful\" but is required to make this code work with GP\u003d1.",
      "parentUuid": "caaf6579_994a6c66",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "251745d8_0e62853e",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-06-23T19:31:11Z",
      "side": 1,
      "message": "There is no complaint. There is a comment and a question with a suggestion. I realized what i missed, conceded i missed it and suggested what i would like the code to look like, ie change the name to make it crystal clear what it does. it is a suggestion. Code matching something already existing does not mean we need not or cannot improve. Since nobody has complained does not mean it is correct. It may have been right for that time but when you make changes the same discussions may surface again. Also note the community is larger and broader so you will likely have more opinions. This is a pointless conversation. Feel free to ignore my comments, since they are suggestions, as you can see in my comment above.\n\n\u003e\u003eThis \"bti j\" instruction is not just \"useful\" but is required to make this code work with GP\u003d1.\nI know and understand this very well. Think about it this way, what good would BTI be if you put it in front of every instruction? Think about if there is an alternate way to write this code. You can most likely write the function modified in amu_helpers.S in C and perhaps you can avoid creating this BTI gadget. The fragment, BTI, MRS, RET is a read system register gadget for ROP/JOP. Can you avoid manually creating obvious gadgets? is there a different way to write/rewrite the code? Open your mind, think of code review comments as suggestions as opposed to a complaint. I\u0027ve resolved the comments.",
      "parentUuid": "4c9c0ed9_6c047692",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b55d406f_9c632922",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2020-06-25T15:43:04Z",
      "side": 1,
      "message": "1. \"...comment and a question with a suggestion...Since nobody has complained does not mean it is correct.\"\n- Why wouldn\u0027t you share your concerns on TF-A mailing list, raise a defect and submit your own  patch to fix the things which are not properly designed/coded/implemented from your point of view?\n2. \"what good would BTI be if you put it in front of every instruction?\"\n- Nobody suggested to put it \"in front of every instruction\". BTI instruction is designed to be put at the start of a function/procedure, and that is what this patch does.\n3. \"You can most likely write the function modified in amu_helpers.S in C...\"\n- The purpose of this patch is to make the existing code work with BTI support, and this task was achieved.\n- I\u0027m desperately looking forward to see your C-implementation of this code. Please provide your own variant of function(s) written in C which read(s) AMEVCNTR0\u003cn\u003e_EL0 registers using \"MRS\" instruction ASAP. Please enlighten me how you do it without assembler.\n4. \"...avoid creating this BTI gadget\"\n- As you \"know and understand this very well\", BTI instruction is designed and used to prevent usage of such gadgets which DO NOT have this instruction. \"BTI gadget\" is a pointless oxymoron without any sense.\n5. \"The fragment, BTI, MRS, RET is a read system register gadget for ROP/JOP. Can you avoid manually creating obvious gadgets?\"\n- See above about this \"gadget\". These functions read AMEVCNTR0\u003cn\u003e_EL0 registers which are as their names imply are accessible from EL0 (and in this TFTF code from NS EL2), so there is no any value in creating a \"gadget\" which would read these registers anyway. As I mentioned previously,the only purpose of this BTI instruction is to make this code work with GP\u003d1, but you already \"know and understand this very well\".\n6. \"This is a pointless conversation\"\n- Exactly.",
      "parentUuid": "251745d8_0e62853e",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "478d3b4d_18b3ed97",
        "filename": "include/common/aarch64/asm_macros.S",
        "patchSetId": 2
      },
      "lineNbr": 203,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-06-25T16:51:05Z",
      "side": 1,
      "message": "DEFINE_SYSREG_READ_FUNC(AMEVCNTR10_EL0) and so on until AMEVCNTR1F_EL0 in arch_helpers.h. And in amu.c:\nstatic uint64_t amu_group1_cnt_read_internal(int idx)\n{\n   assert(idx \u003c 0x10);\n   switch(idx) {\n     case 1:\n         return read_amevcntr10_el0();\n     case 2:\n         return read_amevcntr11_el0();\n     ... and so on\n   }\n}\nThis is ONE implementation. you can do it any other way you\u0027d like. Why would this not work and why does it have to be in assembly? I may be missing something, so feel free to educate me without feeling the need to get defensive or lash out.\n\nThis is very clear to a reader(me) who is not the author(you), that you read ONE register and return. In amu_helpers.S, the continuous lines of read looks there are multiple reads at first glance. The macro is named \"read\", which gives no indication to the reader that there is a return after a read. amu_helpers.S looks like a function that reads 15 registers, as opposed to one.\n\n\u003e\u003eThe purpose of this patch is to make the existing code work with BTI support, and this task \u003e\u003e was achieved.\n\nYes, it achieved YOUR purpose. But did it do so in a way that is acceptable to the community? Maybe you can make a few changes without too much extra effort and it does more than merely work with BTI? Maybe it can improve the code\u0027s readability? I\u0027m part of the community and i  gave you suggestions that could potentially improve the code\u0027s readability, which you failed to even consider and one that you took as a complaint, instead responding with a bunch of \"what about\u0027s\".\n\n\u003e\u003eWhy wouldn\u0027t you share your concerns on TF-A mailing list, raise a defect and submit your own  \u003e\u003epatch to fix the things which are not properly designed/coded/implemented from your point of \u003e\u003e view?\n\nI can and i will. I\u0027ve done that previously too with fconf, barriers and many other topics including measured boot. The whole point of code review is so that developers don\u0027t put whatever code they feel like, that makes it hard for everybody else to use it. This is not an ARM only project anymore, and even if it was, it is in our best interest to serve the community\u0027s need and not only yourself and engage in a constructive way. That is the whole point of having maintainers, reviewers etc, to voice their opinion and concerns and see if we can write code that improves the project and serves a larger audience. Don\u0027t take it personally.\n\n\u003e\"BTI gadget\" is a pointless oxymoron without any sense\n\nExactly my point with your usage of BTI. You have made the BTI instruction COMPLETELY useless in these marcro\u0027s by inserting it before an mrs and a ret. All you are doing is that is that you found that you cannot execute the code with BTI enabled, so you added a BTI blindly \"just to make it work\". I\u0027m asking you to see if there is way to remove the whole read and write macro instead, since it is a gadget, with or without the BTI instruction. There is plenty of other assembly code too and blindly spraying the code with BTI instructions to \"make it work\" defeats the whole purpose of BTI. If you write it as a C function like i suggested above, it MAY be possible that the compiler generates code that may avoid these macros and hence the gadget. I say MAY, because i recognize it may not be possible and we may have to live with this implementation.",
      "parentUuid": "b55d406f_9c632922",
      "revId": "2b6c618d8f2c1e1832749b7e8e9fb962a547612e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}