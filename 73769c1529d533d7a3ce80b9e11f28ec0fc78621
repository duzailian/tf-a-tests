{
  "comments": [
    {
      "key": {
        "uuid": "f0625209_8814b72a",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 20,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "I think we can remove this instruction barrier, as it should be enough to synchronize the context once after both updates to HCR and CPTR.",
      "range": {
        "startLine": 20,
        "startChar": 2,
        "endLine": 20,
        "endChar": 8
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ae7da4c_c24a757d",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "The fact that CPTR_EL2 resets to an architecturally unknown value means we should not use a read/update/write pattern here. Otherwise, we\u0027re just setting the TFP and TZ bits to known values but the rest of the register remains to whatever value the hardware resets to.\n\nInstead, we should directly program the value we want (just like HCR_EL2 above).",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7b7bb067_867eeba8",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T09:46:41Z",
      "side": 1,
      "message": "Well, I would argue that this is not necessarily a problem. We only care about TFP and TZ, and the other bits of the register shouldn\u0027t have any effect (otherwise they would architecturally reset to a safe value). If we assume that this code is wrong, we have always had a bug in the TFTF.",
      "parentUuid": "1ae7da4c_c24a757d",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c8491b1d_c4bea109",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000080
      },
      "writtenOn": "2019-03-29T09:54:52Z",
      "side": 1,
      "message": "Actually I read too quickly through the description of this register. The TAM field is the only one which doesn\u0027t seem to be related to SVE instructions and/or registers trapping.\nSo I would tend to agree with Sandrine.",
      "parentUuid": "7b7bb067_867eeba8",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35a3e11a_28cd5997",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000080
      },
      "writtenOn": "2019-03-29T09:57:45Z",
      "side": 1,
      "message": "(TAM and TTA)",
      "parentUuid": "c8491b1d_c4bea109",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eca14fa6_e372899e",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T09:58:10Z",
      "side": 1,
      "message": "Sure, but there are lots of EL2 registers we never touch that also reset to architecturally UNKNOWN values, so why do we specifically care about this one and not the rest?",
      "parentUuid": "c8491b1d_c4bea109",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f7d43894_3b4f448e",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T10:04:26Z",
      "side": 1,
      "message": "\u003e and the other bits of the register shouldn\u0027t\n \u003e have any effect (otherwise they would architecturally reset to a\n \u003e safe value).\n\nI don\u0027t understand the causal link between these 2 sentences. I was not aware of any such guarantee by the Arm architecture. Then why did we create patches like these ones in TF-A?\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/commit/?id\u003d18f2efd67d881fe0a9a535ce9e801e60d746e024\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/commit/?id\u003d939f66d6c46a8fe8cac708ac8e52afea3ff7a095\n\n \u003e If we assume that this code is wrong, we have always\n \u003e had a bug in the TFTF.\n\nYes, that\u0027s what I believe. It might be that it never showed up because the reset value on FVP and Juno happens to be what we want.",
      "parentUuid": "7b7bb067_867eeba8",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f90af98_74c06512",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T10:06:28Z",
      "side": 1,
      "message": "\u003e Sure, but there are lots of EL2 registers we never touch that also\n \u003e reset to architecturally UNKNOWN values, so why do we specifically\n \u003e care about this one and not the rest?\n\nIt\u0027s not what we do not care about the rest of them, I think we should also initialize them (in a subsequent patch) but we happened to pick the issue for CPTR_EL2 in this review.",
      "parentUuid": "eca14fa6_e372899e",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d6102bd_e34a7a92",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T10:10:41Z",
      "side": 1,
      "message": "SVE was added as part of ARMv8.2. If you have a binary that was built for 8.0, before 8.2 was designed, it shouldn\u0027t be affected by additions of 8.2. Logically all 8.2 features are disabled by default and all important fields of the newly added registers reset to safe values. If not, running an old binary in a new CPU would cause problems.",
      "parentUuid": "8f90af98_74c06512",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d610b2c_2e8d8f6c",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T10:17:17Z",
      "side": 1,
      "message": "What I mean is that if we only care about SVE, we should only be touching the SVE fields. The others, as far as I know, shouldn\u0027t matter. As far as I am aware all fields that reset to UNKNOWN values do it because it is safe to do it. There is always an enable bit somewhere else that architecturally resets to \"disabled\"",
      "parentUuid": "0d6102bd_e34a7a92",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d74beaee_810f9e03",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T10:24:21Z",
      "side": 1,
      "message": "Right, I see, thanks.\n\nThat means we\u0027re safe regarding the bits controlling post-Armv8.0 architectural features but I think the issue remains for other bits that were there from the beginning and reset to an architecturally unknown value (e.g. TCPAC bit).\n\n \u003e As far as I am aware all fields that reset to UNKNOWN values \n \u003e do it because it is safe to do it. There is always an enable \n \u003e bit somewhere else that architecturally resets to \"disabled\"\n\nBut then (reiterating my question), why were the TF-A patches I linked required? I still don\u0027t get it...",
      "parentUuid": "8d610b2c_2e8d8f6c",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "24895930_57efdee0",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T10:43:44Z",
      "side": 1,
      "message": "\u003e But then (reiterating my question), why were the TF-A patches I linked required? I still don\u0027t get it...\n\nWell, maybe they were not needed at all.\n\nI\u0027ve taken a quick look and I can already spot a mistake:\n\nhttps://github.com/ARM-software/arm-trusted-firmware/commit/18f2efd67d881fe0a9a535ce9e801e60d746e024?diff\u003dunified#diff-6515701a234455ea3e91be495ff339f7\n\n```\n-\tldr\tr1, \u003d(SCTLR_RES1 | SCTLR_I_BIT | SCTLR_A_BIT)\n+\tldr\tr1, \u003d(SCTLR_I_BIT | SCTLR_A_BIT)\n```\n\nThis is failing to set to 1 some RES1 bits.\n\nIn short, just because we have done something in the TF it doesn\u0027t mean it\u0027s right. I\u0027m not going to review all both patches (the first one is huge), but I do believe that some of the things done there are not needed.",
      "parentUuid": "d74beaee_810f9e03",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5b834c1a_13062e8d",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T10:45:17Z",
      "side": 1,
      "message": "Actually, sorry, I didn\u0027t notice it was being initialized somewhere else.",
      "parentUuid": "24895930_57efdee0",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "73ddec53_4d06c9ac",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T10:48:24Z",
      "side": 1,
      "message": "In any case, this is a discussion for a different time.\n\nIn this specific case none of the other fields in the register really matter. They all control features that we don\u0027t care about in the TFTF, so I don\u0027t think that read-modify-write is a bug.",
      "parentUuid": "5b834c1a_13062e8d",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7bdc277c_721bc490",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-04-01T07:12:43Z",
      "side": 1,
      "message": "Revisiting the initialization of all other EL2 registers is obviously outside of the scope of this patch (there is no harm discussing it now, though). However, this is new code and AFAIU we have to configure CPTR_EL2 for SVE support.\n\nThere are 2 ways to do it:\n1) either using a read/modify/write pattern like it is in this patch right now;\n2) or we fully initialize the value.\n\nRegardless of whether the 1st approach would be a bug or not, I would prefer we go with the 2nd option because it is more deterministic, unless we can foresee a good reason for not doing so.\n\nThis means doing something like the following:\n\n write_cptr_el2(CPTR_EL2_RES1);\n\nor if we want to make the TZ and TFP bits programming explicit:\n\n  write_cptr_el2(CPTR_EL2_RES1 \u0026 ~CPTR_EL2_TFP_BIT \u0026 ~CPTR_EL2_TZ_BIT);",
      "parentUuid": "73ddec53_4d06c9ac",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b471d726_0314564e",
        "filename": "tftf/tests/extensions/sve/test_sve.c",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "This is a bit too vague IMO. We could add a bit more information, like:\n\n Execute some SVE instructions. These should not be trapped to \n EL3, as TF-A is responsible for enabling SVE for Non-secure\n world.\n\n If they are trapped, we won\u0027t recover from that and the test\n session will effectively be aborted.",
      "range": {
        "startLine": 25,
        "startChar": 14,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "117520c4_32b42f95",
        "filename": "tftf/tests/extensions/sve/test_sve.c",
        "patchSetId": 6
      },
      "lineNbr": 31,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "It\u0027s better to use tftf_testcase_printf() for this kind of messages. INFO() messages are printed as the test goes on so it can be easily missed out in the flow of other UART output messages if the log level is high. As such, it\u0027s better suited for debugging information.\n\nOn the other hand, tftf_testcase_printf() stores the message into the test report so it gets displayed at the end of test session. Both the test status (skipped) and the reason why it was skipped are then displayed at the same place.\n\n(Note that then you can get rid of the function naming printing here, as well as the \"skipped because\" part, because the message will be printed just below the test result and test name so this would become redundant information).",
      "range": {
        "startLine": 31,
        "startChar": 2,
        "endLine": 31,
        "endChar": 6
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}