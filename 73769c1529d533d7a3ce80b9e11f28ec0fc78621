{
  "comments": [
    {
      "key": {
        "uuid": "f0625209_8814b72a",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 20,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "I think we can remove this instruction barrier, as it should be enough to synchronize the context once after both updates to HCR and CPTR.",
      "range": {
        "startLine": 20,
        "startChar": 2,
        "endLine": 20,
        "endChar": 8
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ae7da4c_c24a757d",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "The fact that CPTR_EL2 resets to an architecturally unknown value means we should not use a read/update/write pattern here. Otherwise, we\u0027re just setting the TFP and TZ bits to known values but the rest of the register remains to whatever value the hardware resets to.\n\nInstead, we should directly program the value we want (just like HCR_EL2 above).",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7b7bb067_867eeba8",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T09:46:41Z",
      "side": 1,
      "message": "Well, I would argue that this is not necessarily a problem. We only care about TFP and TZ, and the other bits of the register shouldn\u0027t have any effect (otherwise they would architecturally reset to a safe value). If we assume that this code is wrong, we have always had a bug in the TFTF.",
      "parentUuid": "1ae7da4c_c24a757d",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c8491b1d_c4bea109",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000080
      },
      "writtenOn": "2019-03-29T09:54:52Z",
      "side": 1,
      "message": "Actually I read too quickly through the description of this register. The TAM field is the only one which doesn\u0027t seem to be related to SVE instructions and/or registers trapping.\nSo I would tend to agree with Sandrine.",
      "parentUuid": "7b7bb067_867eeba8",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35a3e11a_28cd5997",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000080
      },
      "writtenOn": "2019-03-29T09:57:45Z",
      "side": 1,
      "message": "(TAM and TTA)",
      "parentUuid": "c8491b1d_c4bea109",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eca14fa6_e372899e",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T09:58:10Z",
      "side": 1,
      "message": "Sure, but there are lots of EL2 registers we never touch that also reset to architecturally UNKNOWN values, so why do we specifically care about this one and not the rest?",
      "parentUuid": "c8491b1d_c4bea109",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f7d43894_3b4f448e",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T10:04:26Z",
      "side": 1,
      "message": "\u003e and the other bits of the register shouldn\u0027t\n \u003e have any effect (otherwise they would architecturally reset to a\n \u003e safe value).\n\nI don\u0027t understand the causal link between these 2 sentences. I was not aware of any such guarantee by the Arm architecture. Then why did we create patches like these ones in TF-A?\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/commit/?id\u003d18f2efd67d881fe0a9a535ce9e801e60d746e024\nhttps://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/commit/?id\u003d939f66d6c46a8fe8cac708ac8e52afea3ff7a095\n\n \u003e If we assume that this code is wrong, we have always\n \u003e had a bug in the TFTF.\n\nYes, that\u0027s what I believe. It might be that it never showed up because the reset value on FVP and Juno happens to be what we want.",
      "parentUuid": "7b7bb067_867eeba8",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f90af98_74c06512",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T10:06:28Z",
      "side": 1,
      "message": "\u003e Sure, but there are lots of EL2 registers we never touch that also\n \u003e reset to architecturally UNKNOWN values, so why do we specifically\n \u003e care about this one and not the rest?\n\nIt\u0027s not what we do not care about the rest of them, I think we should also initialize them (in a subsequent patch) but we happened to pick the issue for CPTR_EL2 in this review.",
      "parentUuid": "eca14fa6_e372899e",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d6102bd_e34a7a92",
        "filename": "tftf/framework/aarch64/arch.c",
        "patchSetId": 6
      },
      "lineNbr": 27,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2019-03-29T10:10:41Z",
      "side": 1,
      "message": "SVE was added as part of ARMv8.2. If you have a binary that was built for 8.0, before 8.2 was designed, it shouldn\u0027t be affected by additions of 8.2. Logically all 8.2 features are disabled by default and all important fields of the newly added registers reset to safe values. If not, running an old binary in a new CPU would cause problems.",
      "parentUuid": "8f90af98_74c06512",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 27,
        "endChar": 42
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b471d726_0314564e",
        "filename": "tftf/tests/extensions/sve/test_sve.c",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "This is a bit too vague IMO. We could add a bit more information, like:\n\n Execute some SVE instructions. These should not be trapped to \n EL3, as TF-A is responsible for enabling SVE for Non-secure\n world.\n\n If they are trapped, we won\u0027t recover from that and the test\n session will effectively be aborted.",
      "range": {
        "startLine": 25,
        "startChar": 14,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "117520c4_32b42f95",
        "filename": "tftf/tests/extensions/sve/test_sve.c",
        "patchSetId": 6
      },
      "lineNbr": 31,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-03-29T09:38:41Z",
      "side": 1,
      "message": "It\u0027s better to use tftf_testcase_printf() for this kind of messages. INFO() messages are printed as the test goes on so it can be easily missed out in the flow of other UART output messages if the log level is high. As such, it\u0027s better suited for debugging information.\n\nOn the other hand, tftf_testcase_printf() stores the message into the test report so it gets displayed at the end of test session. Both the test status (skipped) and the reason why it was skipped are then displayed at the same place.\n\n(Note that then you can get rid of the function naming printing here, as well as the \"skipped because\" part, because the message will be printed just below the test result and test name so this would become redundant information).",
      "range": {
        "startLine": 31,
        "startChar": 2,
        "endLine": 31,
        "endChar": 6
      },
      "revId": "73769c1529d533d7a3ce80b9e11f28ec0fc78621",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}