{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d264851e_82b38b85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-09-12T13:18:38Z",
      "side": 1,
      "message": "LGTM.\nIn my understanding, altogether 2 issues resolved here:\n\n* Skipping the tests rather than passing as its tough to identify b/w \n  undef_injection and other EL2 TRAPS as both return same error. So its better to \n  skip, when hardware doesn\u0027t support feature.\n\n* Test should be validating software than hardware. So when the ID register \n  indicate \"no\" skipping the test is the best option.\n\n* Splitting the test for better maintenance of the overall test_suite. It also \n  gives better clarity on which feature test was skipped/passed/failed.\n\n@Arvind / @Manish P, kindly have a look and share your thoughts.",
      "revId": "6e0aa30326defce750cafc529489e146e51de3c2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6e2bd0c_b7079879",
        "filename": "tftf/tests/misc_tests/test_asymmetric_features.c",
        "patchSetId": 2
      },
      "lineNbr": 227,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-10-23T10:47:37Z",
      "side": 1,
      "message": "IIUC, if the test is not skipped on one of the CPUs during this iteration, the loop breaks. Should we also check the failure/success response from all CPUs, and if any CPU fails, mark the test as a failure otherwise success.\n\nI\u0027m considering a scenario where, for example, the test passes on the lead CPU but fails on a non-lead CPU. In this case, the loop would break after the first CPU, ignoring the failure from the other non-lead CPUs. IIUC, the current logic only returns the test result at line 234 based on the lead CPU\u0027s response, potentially overlooking failures from other CPUs.\n\nPossibly I\u0027m missing something.",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 227,
        "endChar": 9
      },
      "revId": "6e0aa30326defce750cafc529489e146e51de3c2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a798b722_32e49ca4",
        "filename": "tftf/tests/misc_tests/test_asymmetric_features.c",
        "patchSetId": 2
      },
      "lineNbr": 227,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-10-23T11:52:12Z",
      "side": 1,
      "message": "Hi,\nLoops breaks, if any of the CPUs in the cluster has executed the test.\n```\nInitially, test_skipped[PLATFORM_CORE_COUNT] \u003d { 0, 0, 0, 0, 0, 0, 0,0} (#line 144)\n```\nThen we run tests on each CPU and this array gets updated for each CPU.\nLets say if CPU1, has executed the test, meaning feature is present in the hardware, in that case this array will be untouched. \nOn the other side, lets say CPU3, does,\u0027t support the feature, meaning test has to be skipped in for that CPU, so the array will be updated, set to true.\ntest_skipped[PLATFORM_CORE_COUNT] \u003d { 0, 0, 0, 1, 0, 0, 0,0} \n\nThis final array will be considred.\n\nIf the array reads 0, for all the CPUS, then feature is present in all the CPUs.\n\n\nSo to summarise,\n```\nif test_skipped[PLATFORM_CORE_COUNT] \u003d { 0, 0, 0, 1, 0, 0, 0,0} \n loop breaks as atleast there was one or even more CPUs which executed the test.\n \nif test_skipped[PLATFORM_CORE_COUNT] \u003d { 1,1,1,1,1,1,1,1} \n loop does not break as there was not even one CPU, which executed the test.\n```",
      "parentUuid": "b6e2bd0c_b7079879",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 227,
        "endChar": 9
      },
      "revId": "6e0aa30326defce750cafc529489e146e51de3c2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15ea502f_4af13b6d",
        "filename": "tftf/tests/misc_tests/test_asymmetric_features.c",
        "patchSetId": 2
      },
      "lineNbr": 227,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-10-23T12:11:52Z",
      "side": 1,
      "message": "Yes, that is correct.\n\nHowever, my question is, in a scenario where the test is executed on CPU3 and CPU4, with the test passing on CPU3 and failing on CPU4, should we mark the overall result as a failure if the test fails on any CPU? Or should we only consider the result from the lead CPU, as it is currently implemented at line 234?\nIIUC above then is there any chance that the lead CPU skip this test? In that case the result is always SUCCESS right?",
      "parentUuid": "a798b722_32e49ca4",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 227,
        "endChar": 9
      },
      "revId": "6e0aa30326defce750cafc529489e146e51de3c2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5879267f_f934cbb5",
        "filename": "tftf/tests/misc_tests/test_asymmetric_features.c",
        "patchSetId": 2
      },
      "lineNbr": 227,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2024-10-23T16:37:17Z",
      "side": 1,
      "message": "With features like SPE or TCR2, EL3 will be transparent meaning if the feature is present then it will be enabled. So, for these case we either expect access going through or early exit at line #91.\n\nTRBE is special case where even if the feature is present in HW EL3 will deliberately disables it, that is why we need exception catching mechanism.\n\nI agree that its bit not clear why SPE and TRBE are treated differently, We need to put some comments.\n\nPlease clean the test for SPE, so that it skips if feature present. if feature is present then we expect it to be accessible, if that does not happen it will crash anyways.",
      "parentUuid": "15ea502f_4af13b6d",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 227,
        "endChar": 9
      },
      "revId": "6e0aa30326defce750cafc529489e146e51de3c2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b3ad8bb_f6cdcd7e",
        "filename": "tftf/tests/misc_tests/test_asymmetric_features.c",
        "patchSetId": 2
      },
      "lineNbr": 227,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-10-24T07:41:53Z",
      "side": 1,
      "message": "This makes sense!\n\nHowever If any non-lead core encounters a failure in the scenarios below (in case of TRBE), the test is simply ignoring that failure, as it only considers the result from the lead CPU.\n\nIf we don\u0027t really need this check, it would be better to remove it. Alternatively, if we want to keep it, we should consider the pass/fail results from all cores before returning a response. This is what my understanding!\n\n\n```\n\tif (exception_triggered[core_pos] !\u003d should_trigger_exception) {\n\t\ttftf_testcase_printf(\"Exception triggered for core \u003d %d \"\n\t\t\t\t     \"when accessing TRB_LIMTR\\n\", core_pos);\n\t\treturn TEST_RESULT_FAIL;\n\t}\n```",
      "parentUuid": "5879267f_f934cbb5",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 227,
        "endChar": 9
      },
      "revId": "6e0aa30326defce750cafc529489e146e51de3c2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2b7d903_e9f6a3bd",
        "filename": "tftf/tests/misc_tests/test_asymmetric_features.c",
        "patchSetId": 2
      },
      "lineNbr": 227,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-10-24T08:34:51Z",
      "side": 1,
      "message": "Will take this part as an improvement and will acknowledge this in the top patch altogether.(https://review.trustedfirmware.org/c/TF-A/tf-a-tests/+/30956/3)",
      "parentUuid": "6b3ad8bb_f6cdcd7e",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 227,
        "endChar": 9
      },
      "revId": "6e0aa30326defce750cafc529489e146e51de3c2",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}