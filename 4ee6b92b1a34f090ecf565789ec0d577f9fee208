{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1005bdd1_fcecdf5a",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-08-11T10:03:31Z",
      "side": 1,
      "message": "uuid of SP_ID(2) should be added to the list of expected_sp_uuids.",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 17,
        "endChar": 3
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8885bf1f_8795d9a9",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-11T17:15:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1005bdd1_fcecdf5a",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 17,
        "endChar": 3
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b78eab0f_50259450",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-08-11T10:03:31Z",
      "side": 1,
      "message": "Is this really needed?\n\nI am thinking that if the SP handled ME it went to Waiting state. After handling the ME interrupt the SP should be in a state in which it is able to handle new requests that aren\u0027t dummy. In other words, should its execution actually reach the message loop?\n\nI am taking this from section 8.3.2.1 of the specication.\nLet me know what you think?",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d62fb28_122272e5",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-11T17:15:40Z",
      "side": 1,
      "message": "I had the same question when I was working on this test. Yes,the SP goes into WAITING state. However, it does not reach message loop[1]. We need to allocate cpu cycles for it to resume in the message loop to process the original direct request message that was interrupted.\n\n[1] https://review.trustedfirmware.org/c/TF-A/tf-a-tests/+/15675/4/spm/cactus/cactus_interrupt.c#117",
      "parentUuid": "b78eab0f_50259450",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e758747a_1deda80b",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-09-07T15:49:30Z",
      "side": 1,
      "message": "Ahh I see.\nWould it be worth refactoring the handling of the ME?\nInstead of sending the response within the IRQ handler, pend somehow that the ME has arrived, finish the handling of the on-going test command handler, and at the very end either send ME response or the actual the cactus command response.\n\nI get this might not be critical given this serves the purpose of testing ME, making this change shows the expected \"correct\" use of ME. Our test code might be used by partners of how to use certain bits of functionality. For that matter I think might be worth changing things slightly.",
      "parentUuid": "1d62fb28_122272e5",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2e1ecc0_1120bd3b",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-09-07T15:53:54Z",
      "side": 1,
      "message": "If changing the cactus_interrupt.c as described above, instead of sending a dummy request at this point, might be worth sending another command from the message loop.\nSomething like: cactus_echo_send_cmd, or cactus_get_last_interrupt_cmd even.",
      "parentUuid": "e758747a_1deda80b",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62a76b8a_c10ba54e",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-09-08T19:35:57Z",
      "side": 1,
      "message": "Hi Joao,\nMy understanding of the managed exit is that it gives an opportunity to the SP to manage its internal state and relinquish control to NWd asap. Hence, by design, it should not finish handling of the on-going work(command handler in the test). So I am not sure if we can refactor handling of the managed exit mechanism.\n\nLet me know your thoughts on this.",
      "parentUuid": "a2e1ecc0_1120bd3b",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a34e4372_49569152",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-09-09T08:52:43Z",
      "side": 1,
      "message": "My point is that if the SP goes to waiting state that means it should be at a stage in which it can handle any request, from any endpoint.\nFrom this implementation, this is not the case. Other endpoints can\u0027t send another cactus command and obtain a response because its execution hasn\u0027t reached the message loop.\nSo the test SP\u0027s implementation doesn\u0027t fit one for the ME enabled configuration.\n\nI understand though that the caller to SP sleep command needs to get the \"elapsed time\". For this, we could add another cactus command: \"last_elapsed_time_cmd\". something like this...\nIt could check if the sender of such request was the last endpoint to call the sleep_cmd, if so provide read and provide the lapsed time; If not, return error.\n\nWith this the sleep_cmd could be changed: to save the id of the most recent caller to this command; and to look for a \"ME\" flag, to be set in the IRQ handler.\nIf the \"ME\" flag is set, do an ME dir response; else return with elapsed time.\n\nAfter doing those changes the tests for ME in TFTF should be:\n- Calling the Sleep Cmd;\n- Expect the ME response;\n- (Optional, although useful validation) Get other SPs to do a direct message request to validate others can communicate with the SP (request echo command was implemented);\n- Send the \"last_elapsed_time\" command, and check if the time was as expected.\n\nLet me know what you think of these suggestions.",
      "parentUuid": "62a76b8a_c10ba54e",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07b7e3cc_57cd5f45",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-09-09T08:54:36Z",
      "side": 1,
      "message": "Suggestions would affect the change:\nhttps://review.trustedfirmware.org/c/TF-A/tf-a-tests/+/15675/6",
      "parentUuid": "a34e4372_49569152",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bc424bc_0216bbdb",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-09-11T19:04:40Z",
      "side": 1,
      "message": "You made a very interesting point. I appreciate that once SP goes into waiting state, it should be able to handle new requests from any endpoint. This is infact why a SP with ME is leveraged in some scenarios.\n\nHowever, I believe there is an important caveat. The above feature is applicable only when an execution context has more than one application thread. When a NS interrupt fires, the running application thread gets preempted and the SP goes to waiting state. It is able to take on new requests since it has other application threads that are still running.\n\nAs you already know, Cactus SP vCPU does not implement application threads. So , in practice, it is equivalent to having a single application thread; which in our scenario got preempted. This is the reason why I think we cannot implement above suggestions.\n\nPlease let me know your thoughts. I would love to discuss with you more.",
      "parentUuid": "07b7e3cc_57cd5f45",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f19b933_c4b8b95f",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-09-12T10:08:20Z",
      "side": 1,
      "message": "I disagree with the point we need to have threads to make it work.\n\nIn the above changes, I was not contemplating bringing up other cores and have concurrency. Which I believe was the reason you mentioned the multi-thread support(?).\n\nThe changes I described above can be done and implemented in sequential single-core execution.\n\nSo TFTF would handle the NS interrupt, and instead of sending a \"dummy request\", it could request another Cactus SP to communicate with the partition that handled the ME. This is single core and single thread.\nI think that in doing that the SP that just handled ME should be able to handle the request from the mentioned Cactus SP.\n\nLet me know if this doesn\u0027t make things clearer.",
      "parentUuid": "0bc424bc_0216bbdb",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a437a9c_684909d7",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2022-09-15T12:59:11Z",
      "side": 1,
      "message": "Hi, I think this design is pretty correct but might have taken a non-harmful shortcut.\nThere is a bit of nuance in that TFTF (or normal world driver) knows from line 113 that the partition has been pre-empted by a NS interrupt while it was doing work. So in any case the driver knows that, after normal world has handled the NS interrupt, it has to resume the partition to let it complete what it was doing and hence the presence of the dummy direct req.\nBecause of the partition message response contents (SP exited because of an interrupt), there is no reason for the driver to emit a fresh direct req. different from the purpose of resuming the partition.\nIn a real TOS implementation though it\u0027s true that the TEE reaches its main loop before handing over to normal world e.g. for OP-TEE:\n\nvFIQ ME traps:\nhttps://github.com/OP-TEE/optee_os/blob/master/core/arch/arm/kernel/thread_a64.S#L1209\nOP-TEE parks current thread:\nhttps://github.com/OP-TEE/optee_os/blob/master/core/arch/arm/kernel/thread_a64.S#L1058\nOP-TEE prepares for nwd exit:\nhttps://github.com/OP-TEE/optee_os/blob/master/core/arch/arm/kernel/thread_spmc_a64.S#L170\nOP-TEE completes ME with a direct resp. and enters the msg loop:\nhttps://github.com/OP-TEE/optee_os/blob/master/core/arch/arm/kernel/thread_spmc_a64.S#L32\n\nOn the driver side, OPTEE_FFA_YIELDING_CALL_RETURN_INTERRUPT is received through the direct resp. and execution resumed to same partition as a consequence:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tee/optee/ffa_abi.c?h\u003dv6.0-rc5#n518\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tee/optee/ffa_abi.c?h\u003dv6.0-rc5#n584\n\nSo in essence OP-TEE could indeed consume a fresh direct request because it is entering the loop before exiting to nwd, but that\u0027s not how the driver is designed. It could be seen as an improvement to update cactus to adopt a behavior similar to OP-TEE although it would not really enable new use cases.\n\nThe analogous scenario with SPs pre-empted w/o ME is that the returned response by the SPMC is FFA_INTERRUPT (in place of direct resp (w3\u003dmanaged exit hint)). The driver has to take a similar action to resume the partition because of the FFA_INTERRUPT response and let it complete its work.",
      "parentUuid": "5f19b933_c4b8b95f",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00f591f0_c49ed397",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-09-15T16:38:45Z",
      "side": 1,
      "message": "As agreed in SPM syncup call today, I will take it up in the next iteration of improvements.",
      "parentUuid": "4a437a9c_684909d7",
      "range": {
        "startLine": 127,
        "startChar": 1,
        "endLine": 128,
        "endChar": 27
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71a5dd65_843109eb",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 194,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2022-08-11T10:03:31Z",
      "side": 1,
      "message": "full stop.",
      "range": {
        "startLine": 194,
        "startChar": 50,
        "endLine": 194,
        "endChar": 58
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "325174b0_148ba62b",
        "filename": "tftf/tests/runtime_services/secure_service/test_ffa_interrupts.c",
        "patchSetId": 4
      },
      "lineNbr": 194,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-11T17:15:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "71a5dd65_843109eb",
      "range": {
        "startLine": 194,
        "startChar": 50,
        "endLine": 194,
        "endChar": 58
      },
      "revId": "4ee6b92b1a34f090ecf565789ec0d577f9fee208",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}