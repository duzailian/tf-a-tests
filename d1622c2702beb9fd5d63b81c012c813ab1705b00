{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "68d799e9_379140c7",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-18T04:00:19Z",
      "side": 1,
      "message": "curious. does this really drop priority and de-activate interrupt? does the SPMC not drop priority when it gets the interrupt?",
      "range": {
        "startLine": 43,
        "startChar": 3,
        "endLine": 43,
        "endChar": 61
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "765970fa_1e36147d",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-08-24T23:46:14Z",
      "side": 1,
      "message": "You are right. This only de-activate the interrupt.",
      "parentUuid": "68d799e9_379140c7",
      "range": {
        "startLine": 43,
        "startChar": 3,
        "endLine": 43,
        "endChar": 61
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41dcbc98_6a406f06",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-18T03:39:28Z",
      "side": 1,
      "message": "this method of handling interrupt is confusing (at least at the moment, so bear with me). Can we do this without consuming the FFA_INTERRUPT in the interrupt handler? The interrupt handler remains simple in that it always calls spm_interrupt_get and the interrupt handler.\nThe FFA_INTERRUPT can always be consumed in the main wait loop. In the wait loop, you know if the interrupts are enabled or disabled so if you see an FFA_INTERRUPT, you simply go back to FFA_MSG_WAIT in the wait loop, which will signal completion of the interrupt...\n\nAlso i dont understand the ffa_run in handle_interrupt. If we follow the above design, can we get rid of the ffa_run? \nI feel like above design is simpler and cleaner as the example to follow..unless i\u0027m missing something..",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3dc4eb77_5d5fbdae",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-08-24T23:46:14Z",
      "side": 1,
      "message": "I thought long and hard about this. When I started implementing test cases to exercise all possible combinations for secure interrupt handling, there wasnt a way for me to keep FFA handling out of interrupt handler. One of the reasons is we(i.e., SPM) dont know about the scenario in which an SP is running. It may or may not use the interrupt id upon resuming. It may or may not have interrupts enabled/masked. \n\nAs per your suggestion, if we chose to disable and enable interrupts explicitly in message loop, I guess it may lead to simplied design. Since Cactus is just a dummy SP, I didnt know what assumptions to make.\n\nIf its okay with you, I would like to merge the patches(after review) based on current design. I will plan to simplify interrupt handling in next iteration.",
      "parentUuid": "41dcbc98_6a406f06",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c542f5fe_a6834280",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-31T15:29:16Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3dc4eb77_5d5fbdae",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "508009c6_702b5161",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-31T15:29:16Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3dc4eb77_5d5fbdae",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f210261_591ff5d9",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-18T03:39:28Z",
      "side": 1,
      "message": "this part is not clear to me..why would this be required? When does the SPMC return 0xFFFF? maybe i need to look at hafnium changes..",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdac84af_4def49ba",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-08-24T23:46:14Z",
      "side": 1,
      "message": "In the scenario where SP is in blocked state, spec says we dont need to pass interrupt id. Hence, I passed 0XFFFF in arg1 to help distinguish between WAITING and BLOCKED state. This is under the assumption that a SP by itself doesnt track its own state. Please take a look at the companion hafnium patches.\n\nHowever, I had a conversation with Achin. He seems to suggest we can track if the SP is currently blocked and the destination VM/SP on which it is blocked. This could change the design of Cactus SP interrupt handling. I am working on this and will push an updated patchset shortly.",
      "parentUuid": "2f210261_591ff5d9",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc8e2b3b_7686f2d2",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-31T15:29:16Z",
      "side": 1,
      "message": "Yes, this is what i would have expected as well, where the SPM tracks the state of the SP vCPUs..",
      "parentUuid": "fdac84af_4def49ba",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef7cdb93_c9841391",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-09-07T19:33:32Z",
      "side": 1,
      "message": "Hi Raghu\nThanks a lot for the review comments.\nPerhaps, I am missing something. Even if SP tracks which VM/SP it is blocked on, it might not be sufficient for signal completion when in the BLOCKED state. Consider the following hypothetical scenario. SP1 is blocked on SP2. SP2 is blocked on SP3. SP3 is currently running a service and gets preempted by a secure interrupt whose target vCPU belongs to SP1. \nSPM resumes SP1 vCPU.  Spec says SP must invoke FFA_RUN but how would it know that it has to invoke FFA_RUN to resume SP3. SPM might know about this but SP1 does not.",
      "parentUuid": "dc8e2b3b_7686f2d2",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}