{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "68d799e9_379140c7",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-18T04:00:19Z",
      "side": 1,
      "message": "curious. does this really drop priority and de-activate interrupt? does the SPMC not drop priority when it gets the interrupt?",
      "range": {
        "startLine": 43,
        "startChar": 3,
        "endLine": 43,
        "endChar": 61
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "765970fa_1e36147d",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-08-24T23:46:14Z",
      "side": 1,
      "message": "You are right. This only de-activate the interrupt.",
      "parentUuid": "68d799e9_379140c7",
      "range": {
        "startLine": 43,
        "startChar": 3,
        "endLine": 43,
        "endChar": 61
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41dcbc98_6a406f06",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-18T03:39:28Z",
      "side": 1,
      "message": "this method of handling interrupt is confusing (at least at the moment, so bear with me). Can we do this without consuming the FFA_INTERRUPT in the interrupt handler? The interrupt handler remains simple in that it always calls spm_interrupt_get and the interrupt handler.\nThe FFA_INTERRUPT can always be consumed in the main wait loop. In the wait loop, you know if the interrupts are enabled or disabled so if you see an FFA_INTERRUPT, you simply go back to FFA_MSG_WAIT in the wait loop, which will signal completion of the interrupt...\n\nAlso i dont understand the ffa_run in handle_interrupt. If we follow the above design, can we get rid of the ffa_run? \nI feel like above design is simpler and cleaner as the example to follow..unless i\u0027m missing something..",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3dc4eb77_5d5fbdae",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-08-24T23:46:14Z",
      "side": 1,
      "message": "I thought long and hard about this. When I started implementing test cases to exercise all possible combinations for secure interrupt handling, there wasnt a way for me to keep FFA handling out of interrupt handler. One of the reasons is we(i.e., SPM) dont know about the scenario in which an SP is running. It may or may not use the interrupt id upon resuming. It may or may not have interrupts enabled/masked. \n\nAs per your suggestion, if we chose to disable and enable interrupts explicitly in message loop, I guess it may lead to simplied design. Since Cactus is just a dummy SP, I didnt know what assumptions to make.\n\nIf its okay with you, I would like to merge the patches(after review) based on current design. I will plan to simplify interrupt handling in next iteration.",
      "parentUuid": "41dcbc98_6a406f06",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c542f5fe_a6834280",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-31T15:29:16Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3dc4eb77_5d5fbdae",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "508009c6_702b5161",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-31T15:29:16Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3dc4eb77_5d5fbdae",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f553103_8d951eca",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-10-22T08:42:34Z",
      "side": 1,
      "message": "I must admit I\u0027m also confused by this implementation. The irq handler should really just consume the virtual IRQ signal (because of HCR_EL2.VI\u003d1). It does not have to peek into the GP regs context. The main loop consumes FFA_INTERRUPT if virtual interrupts are masked (PSTATE.I\u003d1).",
      "parentUuid": "c542f5fe_a6834280",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "faf94ff8_6291cdd8",
        "filename": "spm/cactus/cactus_interrupt.c",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-10-26T20:10:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8f553103_8d951eca",
      "range": {
        "startLine": 82,
        "startChar": 1,
        "endLine": 82,
        "endChar": 37
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f210261_591ff5d9",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-18T03:39:28Z",
      "side": 1,
      "message": "this part is not clear to me..why would this be required? When does the SPMC return 0xFFFF? maybe i need to look at hafnium changes..",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdac84af_4def49ba",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-08-24T23:46:14Z",
      "side": 1,
      "message": "In the scenario where SP is in blocked state, spec says we dont need to pass interrupt id. Hence, I passed 0XFFFF in arg1 to help distinguish between WAITING and BLOCKED state. This is under the assumption that a SP by itself doesnt track its own state. Please take a look at the companion hafnium patches.\n\nHowever, I had a conversation with Achin. He seems to suggest we can track if the SP is currently blocked and the destination VM/SP on which it is blocked. This could change the design of Cactus SP interrupt handling. I am working on this and will push an updated patchset shortly.",
      "parentUuid": "2f210261_591ff5d9",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc8e2b3b_7686f2d2",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-31T15:29:16Z",
      "side": 1,
      "message": "Yes, this is what i would have expected as well, where the SPM tracks the state of the SP vCPUs..",
      "parentUuid": "fdac84af_4def49ba",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef7cdb93_c9841391",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-09-07T19:33:32Z",
      "side": 1,
      "message": "Hi Raghu\nThanks a lot for the review comments.\nPerhaps, I am missing something. Even if SP tracks which VM/SP it is blocked on, it might not be sufficient for signal completion when in the BLOCKED state. Consider the following hypothetical scenario. SP1 is blocked on SP2. SP2 is blocked on SP3. SP3 is currently running a service and gets preempted by a secure interrupt whose target vCPU belongs to SP1. \nSPM resumes SP1 vCPU.  Spec says SP must invoke FFA_RUN but how would it know that it has to invoke FFA_RUN to resume SP3. SPM might know about this but SP1 does not.",
      "parentUuid": "dc8e2b3b_7686f2d2",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e79be1c_b9c19684",
        "filename": "spm/cactus/cactus_main.c",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-09-11T22:07:26Z",
      "side": 1,
      "message": "yep, explanation makes sense to me. However, An SP does not necessarily require to know through an error code. In your hypothetical situation, SPM resumes SP1 vCPU and has injected the interrupt. Assuming interrupts are not masked, the interrupt fires, interrupt is handled, interrupt handler calls deactivate, and then erets to S-EL1 code where it had called, say direct_req, that made it enter the blocked state. Now, when the interrupt handler ERET resumes this, your direct_req call will see an error code of FFA_INTERRUPT and it \"knows\", oh interrupts were enabled, and it must have been handled, let me just call ffa_run...does that make sense? in that way, the interrupt handler does not need to do much with ffa calls at all. that would all live in the main non-interrupt code executing on the vcpu..",
      "parentUuid": "ef7cdb93_c9841391",
      "range": {
        "startLine": 95,
        "startChar": 14,
        "endLine": 95,
        "endChar": 34
      },
      "revId": "d1622c2702beb9fd5d63b81c012c813ab1705b00",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}