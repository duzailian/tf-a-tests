{
  "comments": [
    {
      "key": {
        "uuid": "ad3bbe49_0fbb14bc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2018-10-12T13:21:24Z",
      "side": 1,
      "message": "nit: typo",
      "range": {
        "startLine": 10,
        "startChar": 48,
        "endLine": 10,
        "endChar": 53
      },
      "revId": "e851393edc8206b7bf2c41625f23542b0dbbfb52",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4018a7e7_5d6cf009",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2018-10-12T14:08:08Z",
      "side": 1,
      "message": "Done",
      "range": {
        "startLine": 10,
        "startChar": 48,
        "endLine": 10,
        "endChar": 53
      },
      "revId": "e851393edc8206b7bf2c41625f23542b0dbbfb52",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "57cb869d_bcea0336",
        "filename": "plat/arm/board/fvp/aarch32/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2018-10-12T13:21:24Z",
      "side": 1,
      "message": "Removing the weak implementation of platform_get_core_pos() makes sense to me because I think its implementation varies too much from one platform port to another.\n\nBut does it make sense for the console functions? I would have assumed that the weak implementations in this file would be quite invariant. We might want to use some PLAT_UART_BASE macro instead of the Arm-specific version but perhaps that\u0027s all we need to make it more generic.\n\nThese weak functions call the console_core_init/putc/flush() functions, which are currently implemented only by the PL011 driver and obviously not all platforms use a PL011 UART so I guess that\u0027s your argument for moving them to the platform layer.\n\nBut console_core_init/putc/flush() seem like generic UART callbacks that any UART driver could potentially implement. In this context, I think this makes these weak functions a sane, default implementation.",
      "revId": "e851393edc8206b7bf2c41625f23542b0dbbfb52",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "be64068c_bf065dd4",
        "filename": "plat/arm/board/fvp/aarch32/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2018-10-12T14:06:49Z",
      "side": 1,
      "message": "It\u0027s obvious that we can\u0027t have PL011 functions as plat/common functions, yes, that\u0027s one of the reasons.\n\nHowever, if we have generic defines we need to make sure that all platforms use standard definitions, and they can\u0027t not define them. The plat/common file is going to be compiled in anyway, so if you want to overload any of the weak functions you still need the defines or you won\u0027t be able to build. It\u0027s easier to simply tell all platforms to implement their own functions.\n\nWe don\u0027t even have generic defines for the UART in the TF because, for example, a platform may only support a baudrate (and then you don\u0027t care about that definition, so why waste an instruction loading 0 to a register?). For example, we have a console driver that simply writes to a memory buffer. All you need is the pointer to it, there is no point in having more defines.",
      "revId": "e851393edc8206b7bf2c41625f23542b0dbbfb52",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1865d1da_41ec83ba",
        "filename": "plat/arm/board/fvp/aarch32/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2018-10-12T15:15:09Z",
      "side": 1,
      "message": "\u003e It\u0027s obvious that we can\u0027t have PL011 functions as plat/common\n \u003e functions, yes, that\u0027s one of the reasons.\n\nBut as I said, console_core_init/putc/flush() don\u0027t have to be PL011-specific, it could be the generic interface that any UART driver has to implement. So then it would not be a problem to call them from common code.\n\n \u003e However, if we have generic defines we need to make sure that all\n \u003e platforms use standard definitions, and they can\u0027t not define them.\n \u003e The plat/common file is going to be compiled in anyway, so if you\n \u003e want to overload any of the weak functions you still need the\n \u003e defines or you won\u0027t be able to build. It\u0027s easier to simply tell\n \u003e all platforms to implement their own functions.\n\nI don\u0027t see a problem here, I would assume that every UART needs a least a base address, clock and baudrate to be properly configured, right?\n\n \u003e We don\u0027t even have generic defines for the UART in the TF because,\n \u003e for example, a platform may only support a baudrate (and then you\n \u003e don\u0027t care about that definition, so why waste an instruction\n \u003e loading 0 to a register?). For example, we have a console driver\n \u003e that simply writes to a memory buffer. All you need is the pointer\n \u003e to it, there is no point in having more defines.\n\nDo you mean that for some UARTs, there is no need to configure the baudrate because it\u0027s hard-wired and cannot be changed? Does it mean that these UARTs work out of reset?",
      "revId": "e851393edc8206b7bf2c41625f23542b0dbbfb52",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c79a77a_3eded253",
        "filename": "plat/arm/board/fvp/aarch32/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2018-10-12T15:19:17Z",
      "side": 1,
      "message": "\u003e But as I said, console_core_init/putc/flush() don\u0027t have to\n\u003e be PL011-specific, it could be the generic interface that\n\u003e any UART driver has to implement. So then it would not be a\n\u003e problem to call them from common code.\n\nSure, and that\u0027s the case now, but that\u0027s not the problem.\n\nThe problem is that there are consoles that may not need baudrate and clock to work. There may be platforms that don\u0027t even want to use our console driver because they want to do something different. By keeping the weak definitions we are forcing them to add the #defines to their platform_def.h even though they don\u0027t need them. Just so that this common file can compile.",
      "revId": "e851393edc8206b7bf2c41625f23542b0dbbfb52",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04ba34a6_ecf60c48",
        "filename": "plat/arm/board/fvp/aarch32/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000050
      },
      "writtenOn": "2018-10-12T15:23:14Z",
      "side": 1,
      "message": "Yes, there are consoles that just need a base. Maybe not even that, maybe there is just one console and you can hardcode it in the driver.",
      "revId": "e851393edc8206b7bf2c41625f23542b0dbbfb52",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}